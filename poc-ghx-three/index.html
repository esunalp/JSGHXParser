<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Grasshopper GHX â†’ Three.js POC</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #111;
        color: #f5f5f5;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .visually-hidden {
        position: absolute !important;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      header {
        padding: 0.75rem 1.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.12);
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
      }

      header h1 {
        margin: 0;
        font-size: 1.25rem;
        letter-spacing: 0.02em;
      }

      header .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      input[type="file"] {
        color: inherit;
      }

      main {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(260px, 320px) 1fr;
        min-height: 0;
      }

      aside {
        border-right: 1px solid rgba(255, 255, 255, 0.12);
        padding: 1rem 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        overflow-y: auto;
      }

      .status {
        font-size: 0.9rem;
        line-height: 1.4;
        color: rgba(255, 255, 255, 0.7);
      }

      .sliders {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .scenario-panel {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.12);
      }

      .scenario-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .scenario-header h2 {
        margin: 0;
        font-size: 1rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
      }

      .scenario-select {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        min-width: 0;
      }

      .scenario-select select {
        appearance: none;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 6px;
        color: inherit;
        font-size: 0.9rem;
        padding: 0.35rem 0.85rem;
        line-height: 1.4;
        transition: border-color 0.2s ease, background 0.2s ease;
      }

      .scenario-select select:focus {
        outline: none;
        border-color: rgba(44, 156, 245, 0.6);
        box-shadow: 0 0 0 2px rgba(44, 156, 245, 0.2);
        background: rgba(44, 156, 245, 0.12);
      }

      .scenario-description {
        margin: 0;
        font-size: 0.85rem;
        line-height: 1.45;
        color: rgba(255, 255, 255, 0.7);
      }

      .graph-status-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .graph-status-empty {
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.55);
        padding: 0.25rem 0;
      }

      .graph-status-item {
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 0.6rem 0.75rem;
        transition: border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
      }

      .graph-status-item--active {
        border-color: rgba(44, 156, 245, 0.7);
        box-shadow: 0 0 0 1px rgba(44, 156, 245, 0.25);
        background: rgba(44, 156, 245, 0.12);
      }

      .graph-status-item--error {
        border-color: rgba(255, 107, 107, 0.8);
        background: rgba(255, 99, 71, 0.12);
      }

      .graph-status-indicator {
        width: 0.75rem;
        height: 0.75rem;
        border-radius: 999px;
        margin-top: 0.2rem;
        flex-shrink: 0;
        background: rgba(255, 255, 255, 0.4);
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.12);
      }

      .graph-status-indicator[data-state='loading'],
      .graph-status-indicator[data-state='pending'] {
        background: rgba(244, 208, 63, 0.9);
        box-shadow: 0 0 0 2px rgba(244, 208, 63, 0.25);
        animation: graph-status-pulse 1.4s ease infinite;
      }

      .graph-status-indicator[data-state='evaluating'] {
        background: rgba(44, 156, 245, 0.9);
        box-shadow: 0 0 0 2px rgba(44, 156, 245, 0.25);
        animation: graph-status-pulse 0.9s ease infinite;
      }

      .graph-status-indicator[data-state='ready'],
      .graph-status-indicator[data-state='idle'] {
        background: rgba(76, 209, 149, 0.9);
        box-shadow: 0 0 0 2px rgba(76, 209, 149, 0.22);
      }

      .graph-status-indicator[data-state='error'] {
        background: rgba(255, 107, 107, 0.9);
        box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.3);
        animation: none;
      }

      .graph-status-content {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .graph-status-row {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .graph-status-name {
        font-weight: 600;
        font-size: 0.95rem;
        letter-spacing: 0.01em;
      }

      .graph-status-state {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        opacity: 0.75;
      }

      .graph-status-message {
        font-size: 0.78rem;
        line-height: 1.35;
        color: rgba(255, 255, 255, 0.75);
      }

      .graph-status-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
      }

      .graph-status-chip {
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        font-size: 0.7rem;
        font-weight: 600;
        letter-spacing: 0.05em;
        padding: 0.1rem 0.55rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.75);
        border: 1px solid rgba(255, 255, 255, 0.12);
      }

      .graph-status-chip[data-kind='role'],
      .graph-status-chip[data-kind='variant'],
      .graph-status-chip[data-kind='sliders'] {
        text-transform: uppercase;
      }

      .graph-status-item--active .graph-status-chip[data-kind='role'] {
        background: rgba(44, 156, 245, 0.18);
        border-color: rgba(44, 156, 245, 0.4);
        color: rgba(173, 216, 255, 0.95);
      }

      .graph-status-item--error .graph-status-chip {
        border-color: rgba(255, 107, 107, 0.45);
        color: rgba(255, 160, 160, 0.95);
      }

      @keyframes graph-status-pulse {
        0% {
          transform: scale(1);
          opacity: 0.85;
        }
        50% {
          transform: scale(1.1);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 0.85;
        }
      }

      .slider {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        padding-left: 0.25rem;
        border-left: 2px solid transparent;
      }

      .slider-label {
        font-weight: 600;
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        align-items: center;
        flex-wrap: wrap;
      }

      .slider-name {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }

      .slider-name-text {
        display: inline-flex;
        align-items: center;
      }

      .slider-value {
        font-size: 0.85rem;
        opacity: 0.75;
        letter-spacing: 0.02em;
      }

      .slider-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 1.6rem;
        padding: 0.15rem 0.45rem;
        border-radius: 999px;
        background: rgba(44, 156, 245, 0.18);
        color: rgba(173, 216, 255, 0.95);
        font-size: 0.7rem;
        font-weight: 600;
        letter-spacing: 0.05em;
        border: 1px solid rgba(44, 156, 245, 0.4);
      }

      .slider[data-graph-count='1'] .slider-badge {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.18);
        color: rgba(255, 255, 255, 0.8);
      }


      .slider-inputs {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 0.75rem;
        align-items: center;
      }

      .slider-meta {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.65);
        line-height: 1.3;
      }

      .slider.slider-warning {
        border-left-color: rgba(255, 204, 128, 0.9);
        background: rgba(255, 165, 0, 0.08);
      }

      .slider.slider-warning .slider-meta {
        color: rgba(255, 220, 170, 0.95);
      }

      .slider-inputs input[type="range"] {
        width: 100%;
      }

      .slider-inputs input[type="number"] {
        width: 4.5rem;
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 4px;
        padding: 0.25rem 0.5rem;
        color: inherit;
      }

      .toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        font-weight: 600;
      }

      .toggle-controls {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .toggle-controls input[type="checkbox"] {
        width: 1.25rem;
        height: 1.25rem;
        accent-color: #2c9cf5;
      }

      .toggle-state {
        font-size: 0.85rem;
        text-transform: lowercase;
        opacity: 0.75;
      }

      .viewport {
        position: relative;
        background: #1a1a1a;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      .loading-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: brightness(1.2);
        transition: opacity 150ms ease;
        opacity: 1;
        pointer-events: auto;
        z-index: 1;
      }

      .loading-overlay--hidden {
        opacity: 0;
        pointer-events: none;
        visibility: hidden;
      }

      .loading-overlay__spinner {
        width: 3rem;
        height: 3rem;
        border-radius: 999px;
        border: 4px solid rgba(255, 255, 255, 0.25);
        border-top-color: #ffffff;
        animation: loading-overlay-spin 0.9s linear infinite;
      }

      @keyframes loading-overlay-spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Three.js GHX Parser â€” Proof of Concept</h1>
      <div class="actions">
        <label>
          <span style="display:none">GHX bestand</span>
          <input id="ghx-input" type="file" accept=".ghx,.xml" />
        </label>
        <output id="status" class="status">Selecteer een scenario om te starten.</output>
      </div>
    </header>
    <main>
      <aside>
        <section class="scenario-panel" aria-labelledby="scenario-title">
          <div class="scenario-header">
            <h2 id="scenario-title">Scenario</h2>
            <label class="scenario-select" for="scenario-select">
              <span class="visually-hidden">Kies scenario</span>
              <select id="scenario-select" name="scenario" aria-describedby="scenario-description"></select>
            </label>
          </div>
          <p id="scenario-description" class="scenario-description"></p>
          <ul id="graph-status-list" class="graph-status-list" aria-live="polite"></ul>
        </section>
        <section>
          <h2 style="margin:0 0 0.5rem 0;font-size:1rem;letter-spacing:0.03em;text-transform:uppercase;">Weergave</h2>
          <label class="toggle">
            <span>Lijnen &amp; punten tonen</span>
            <span class="toggle-controls">
              <input id="overlay-toggle" type="checkbox" role="switch" aria-checked="false" aria-label="Toon lijnen en punten" />
              <span id="overlay-state" class="toggle-state">false</span>
            </span>
          </label>
        </section>
        <section>
          <h2 style="margin:0 0 0.5rem 0;font-size:1rem;letter-spacing:0.03em;text-transform:uppercase;">Sliders</h2>
          <div id="slider-container" class="sliders" aria-live="polite"></div>
        </section>
      </aside>
      <section class="viewport">
        <canvas id="viewport" aria-label="3D weergave"></canvas>
      </section>
    </main>
    <script type="importmap">
      {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.webgpu.js",
            "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.webgpu.js",
            "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.tsl.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import { withVersion } from './version.js';

      const versionedImport = (path) => import(withVersion(path));

      const [
        { initScene },
        { createEngine },
        { defaultRegistry },
        { createSliderUI },
        { createGraphRegistry },
        { GHXWorkerManager },
        { deserializeDisplayPayload },
      ] = await Promise.all([
        versionedImport('./three-scene.js'),
        versionedImport('./engine.js'),
        versionedImport('./registry.js'),
        versionedImport('./ui.js'),
        versionedImport('./graph-registry.js'),
        versionedImport('./worker-manager.js'),
        versionedImport('./renderable-transfer.js'),
      ]);

      const canvas = document.getElementById('viewport');
      const statusEl = document.getElementById('status');
      const sliderContainer = document.getElementById('slider-container');
      const scenarioSelect = document.getElementById('scenario-select');
      const scenarioDescription = document.getElementById('scenario-description');
      const graphStatusList = document.getElementById('graph-status-list');
      const fileInput = document.getElementById('ghx-input');
      const overlayToggle = document.getElementById('overlay-toggle');
      const overlayState = document.getElementById('overlay-state');

      const SCENARIOS = [
        {
          id: 'demo-basis',
          label: 'Demobrug â€” basisset',
          description:
            'Combineert het wireframe met voorbeeldgraphs voor omgeving en leuning om gedeelde sliders te demonstreren.',
          graphs: [
            {
              id: 'wireframe',
              label: 'Wireframe',
              file: './lijntest.ghx',
              role: 'wireframe',
              primary: true,
            },
            //  {
            //    id: 'omgeving-a',
            //    label: 'Omgeving variant A',
            //    file: './test3.ghx',
            //    role: 'omgeving',
            //    variant: 'A',
            //  },
            //  {
            //    id: 'leuning-concept',
            //    label: 'Leuning concept',
            //    file: './test4.ghx',
            //    role: 'leuning',
            //    variant: 'concept',
            //  },
          ],
        },
        {
          id: 'alternatief-lijn',
          label: 'Alternatieve testopstelling',
          description: 'Combineert een alternatieve wireframe-graph met een lijntest-overlay.',
          graphs: [
            {
              id: 'wireframe-test',
              label: 'Wireframe (test)',
              file: './brugtest.ghx',
              role: 'wireframe',
              primary: true,
            },
            {
              id: 'lijnen-overlay',
              label: 'Lijn-overlay',
              file: './lijntest.ghx',
              role: 'overlay',
              variant: 'lijnen',
            },
          ],
        },
      ];

      const scenariosById = new Map(SCENARIOS.map((scenario) => [scenario.id, scenario]));

      const slugify = (value, fallback = 'graph') => {
        if (!value || typeof value !== 'string') {
          return fallback;
        }
        const normalized = value
          .normalize('NFKD')
          .replace(/[^\w\s-]+/g, '')
          .trim()
          .toLowerCase()
          .replace(/[\s_-]+/g, '-');
        return normalized || fallback;
      };

      const createScenarioGraphId = (scenarioId, graphConfig = {}) => {
        const scenarioPart = slugify(scenarioId ?? 'scenario');
        const graphPart = slugify(graphConfig.id ?? graphConfig.label ?? graphConfig.file ?? 'graph');
        return `scenario-${scenarioPart}-${graphPart}`;
      };

      const graphStatusRecords = new Map();
      let graphStatusOrderCounter = 0;

      const STATUS_LABELS = {
        pending: 'In wachtrij',
        loading: 'Ladenâ€¦',
        ready: 'Gereed',
        evaluating: 'Evaluatieâ€¦',
        error: 'Fout',
        idle: 'Inactief',
      };

      const renderGraphStatusList = () => {
        if (!graphStatusList) {
          return;
        }
        graphStatusList.innerHTML = '';
        if (graphStatusRecords.size === 0) {
          const empty = document.createElement('li');
          empty.className = 'graph-status-empty';
          empty.textContent = 'Selecteer een scenario om grafieken te laden.';
          graphStatusList.appendChild(empty);
          return;
        }

        const entries = Array.from(graphStatusRecords.values()).sort((a, b) => {
          const orderA = Number.isFinite(a.order) ? a.order : Number.MAX_SAFE_INTEGER;
          const orderB = Number.isFinite(b.order) ? b.order : Number.MAX_SAFE_INTEGER;
          if (orderA !== orderB) return orderA - orderB;
          const labelA = a.label ?? a.graphId ?? '';
          const labelB = b.label ?? b.graphId ?? '';
          return labelA.localeCompare(labelB);
        });

        for (const record of entries) {
          const item = document.createElement('li');
          item.className = 'graph-status-item';
          if (record.isActive) {
            item.classList.add('graph-status-item--active');
          }
          if (record.state === 'error') {
            item.classList.add('graph-status-item--error');
          }
          item.dataset.graphId = record.graphId;

          const indicator = document.createElement('span');
          indicator.className = 'graph-status-indicator';
          indicator.dataset.state = record.state ?? 'idle';
          item.appendChild(indicator);

          const content = document.createElement('div');
          content.className = 'graph-status-content';
          item.appendChild(content);

          const row = document.createElement('div');
          row.className = 'graph-status-row';
          content.appendChild(row);

          const name = document.createElement('span');
          name.className = 'graph-status-name';
          name.textContent = record.label ?? record.graphId ?? 'Onbekende grafiek';
          row.appendChild(name);

          const stateLabel = document.createElement('span');
          stateLabel.className = 'graph-status-state';
          stateLabel.textContent = STATUS_LABELS[record.state] ?? '';
          row.appendChild(stateLabel);

          const messageText = record.message ?? record.summary ?? '';
          if (messageText) {
            const message = document.createElement('div');
            message.className = 'graph-status-message';
            message.textContent = messageText;
            content.appendChild(message);
          }

          const chips = [];
          if (record.role) {
            chips.push({ kind: 'role', text: record.role });
          }
          if (record.variant) {
            chips.push({ kind: 'variant', text: record.variant });
          }
          if (record.sliderCount !== undefined && record.sliderCount !== null) {
            const sliderCount = Number(record.sliderCount);
            if (Number.isFinite(sliderCount)) {
              chips.push({
                kind: 'sliders',
                text: sliderCount === 1 ? '1 slider' : `${sliderCount} sliders`,
              });
            }
          }
          if (record.sourceLabel) {
            chips.push({ kind: 'source', text: record.sourceLabel });
          }
          if (record.scenarioLabel && record.scenarioLabel !== record.label) {
            chips.push({ kind: 'scenario', text: record.scenarioLabel });
          }

          if (chips.length) {
            const meta = document.createElement('div');
            meta.className = 'graph-status-meta';
            for (const chip of chips) {
              const span = document.createElement('span');
              span.className = 'graph-status-chip';
              span.dataset.kind = chip.kind;
              span.textContent = chip.text;
              meta.appendChild(span);
            }
            content.appendChild(meta);
          }

          graphStatusList.appendChild(item);
        }
      };

      const updateGraphStatus = (graphId, updates = {}, { createIfMissing = false } = {}) => {
        if (!graphId) {
          return;
        }
        let record = graphStatusRecords.get(graphId);
        if (!record) {
          if (!createIfMissing) {
            return;
          }
          record = {
            graphId,
            state: 'idle',
            order: graphStatusOrderCounter++,
          };
          graphStatusRecords.set(graphId, record);
        }

        if (typeof updates.order === 'number' && Number.isFinite(updates.order)) {
          record.order = updates.order;
          if (updates.order >= graphStatusOrderCounter) {
            graphStatusOrderCounter = updates.order + 1;
          }
        }

        for (const [key, value] of Object.entries(updates)) {
          if (key === 'order') {
            continue;
          }
          if (value === undefined) {
            continue;
          }
          if (key === 'source') {
            record.source = value;
            record.sourceLabel = typeof value === 'string' ? value.split('/').pop() ?? value : value;
            continue;
          }
          record[key] = value;
        }

        record.updatedAt = new Date();
        graphStatusRecords.set(graphId, record);
        renderGraphStatusList();
      };

      const resetGraphStatuses = () => {
        graphStatusRecords.clear();
        graphStatusOrderCounter = 0;
        renderGraphStatusList();
      };

      const reflectActiveGraphInStatus = (activeGraphId) => {
        let dirty = false;
        for (const record of graphStatusRecords.values()) {
          const next = record.graphId === activeGraphId;
          if (record.isActive !== next) {
            record.isActive = next;
            dirty = true;
          }
        }
        if (dirty) {
          renderGraphStatusList();
        }
      };

      renderGraphStatusList();

      const populateScenarioOptions = () => {
        if (!scenarioSelect) {
          return;
        }
        scenarioSelect.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'â€” Selecteer scenario â€”';
        placeholder.selected = true;
        scenarioSelect.appendChild(placeholder);
        if (!SCENARIOS.length) {
          placeholder.textContent = 'Geen scenario\'s beschikbaar';
          scenarioSelect.disabled = true;
          return;
        }
        for (const scenario of SCENARIOS) {
          const option = document.createElement('option');
          option.value = scenario.id;
          option.textContent = scenario.label;
          scenarioSelect.appendChild(option);
        }
        scenarioSelect.disabled = false;
      };

      const setScenarioDescription = (scenario) => {
        if (!scenarioDescription) {
          return;
        }
        if (!scenario) {
          scenarioDescription.textContent =
            'Kies een scenario om een samengestelde set GHX-bestanden in te laden.';
          return;
        }
        scenarioDescription.textContent = scenario.description ?? '';
      };

      populateScenarioOptions();
      setScenarioDescription(null);

      let currentScenarioToken = null;
      let activeScenarioId = null;

      const loadScenarioById = async (scenarioId) => {
        const scenario = scenarioId ? scenariosById.get(scenarioId) : null;
        if (!scenario) {
          activeScenarioId = null;
          setScenarioDescription(null);
          statusEl.textContent = 'Selecteer een scenario om te starten.';
          resetGraphStatuses();
          const existing = graphRegistry.listGraphs();
          for (const entry of existing) {
            graphRegistry.removeGraph(entry.id);
          }
          return;
        }

        activeScenarioId = scenario.id;
        setScenarioDescription(scenario);

        const token = Symbol(`scenario:${scenario.id}`);
        currentScenarioToken = token;

        statusEl.textContent = `Scenario "${scenario.label}" wordt geladen...`;
        const overlayToken = showLoadingOverlay();

        const existingGraphs = graphRegistry.listGraphs();
        for (const entry of existingGraphs) {
          graphRegistry.removeGraph(entry.id);
        }
        resetGraphStatuses();

        if (!Array.isArray(scenario.graphs) || scenario.graphs.length === 0) {
          statusEl.textContent = `Scenario "${scenario.label}" bevat geen grafieken om te laden.`;
          hideLoadingOverlay(overlayToken);
          return;
        }

        let primaryGraphId = null;
        const loadedGraphIds = [];
        let loadErrors = 0;

        for (let index = 0; index < scenario.graphs.length; index += 1) {
          if (currentScenarioToken !== token) {
            hideLoadingOverlay(overlayToken);
            return;
          }
          const graphConfig = scenario.graphs[index] ?? {};
          const graphId = createScenarioGraphId(scenario.id, graphConfig);
          const displayLabel = graphConfig.label ?? graphConfig.id ?? `Graph ${index + 1}`;
          const sourcePath = graphConfig.file ?? '';
          const metadata = {
            label: displayLabel,
            role: graphConfig.role ?? null,
            variant: graphConfig.variant ?? null,
            scenarioId: scenario.id,
            scenarioLabel: scenario.label,
            source: sourcePath,
            primary: graphConfig.primary === true,
            order: index,
          };

          updateGraphStatus(
            graphId,
            {
              label: displayLabel,
              state: 'loading',
              message: 'Bestand wordt geladenâ€¦',
              role: metadata.role,
              variant: metadata.variant,
              scenarioId: scenario.id,
              scenarioLabel: scenario.label,
              source: sourcePath,
              order: index,
            },
            { createIfMissing: true },
          );

          try {
            if (!sourcePath) {
              throw new Error('Geen bestandspad opgegeven.');
            }
            const response = await fetch(sourcePath, { cache: 'no-store' });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            const contents = await response.text();
            if (currentScenarioToken !== token) {
              hideLoadingOverlay(overlayToken);
              return;
            }

            const parseResult = await workerManager.parseText(contents, {
              name: sourcePath.split('/').pop() ?? sourcePath,
              graphId,
              metadata,
              prefix: scenario.id,
              setActive: graphConfig.primary === true,
            });

            if (currentScenarioToken !== token) {
              hideLoadingOverlay(overlayToken);
              return;
            }

            engine.loadGraph(parseResult.graph, {
              id: parseResult.graphId,
              metadata: parseResult.metadata,
            });

            const sliderCount = parseResult.metadata?.sliderCount ?? parseResult.sliders?.length;
            updateGraphStatus(graphId, {
              state: 'ready',
              message: parseResult.summary ?? 'Grafiek geladen.',
              summary: parseResult.summary,
              sliderCount,
            });

            loadedGraphIds.push(parseResult.graphId);
            if (graphConfig.primary) {
              primaryGraphId = parseResult.graphId;
            }
          } catch (error) {
            console.error('Scenario graph load error', error);
            loadErrors += 1;
            updateGraphStatus(graphId, {
              state: 'error',
              error: error?.message ?? String(error),
              message: `Fout bij laden: ${error?.message ?? 'onbekende fout'}`,
            });
          }
        }

        if (currentScenarioToken !== token) {
          hideLoadingOverlay(overlayToken);
          return;
        }

        if (!loadedGraphIds.length) {
          statusEl.textContent = `Scenario "${scenario.label}" kon niet worden geladen.`;
          hideLoadingOverlay(overlayToken);
          graphRegistry.setActiveGraph(null);
          return;
        }

        const targetGraphId = primaryGraphId ?? loadedGraphIds[0];
        graphRegistry.setActiveGraph(targetGraphId);

        try {
          await engine.evaluate({ reason: 'scenario-load' });
        } catch (error) {
          console.error('Scenario evaluation error', error);
        }

        const successCount = loadedGraphIds.length;
        const summaryText = loadErrors
          ? `${successCount} van ${scenario.graphs.length} grafieken geladen; ${loadErrors} fout${loadErrors === 1 ? '' : 'en'}.`
          : `${successCount} grafieken geladen.`;
        statusEl.textContent = `Scenario "${scenario.label}" geladen â€” ${summaryText}`;
        currentScenarioToken = null;
        hideLoadingOverlay(overlayToken);
      };

      if (scenarioSelect) {
        scenarioSelect.addEventListener('change', (event) => {
          const selectedId = event.target.value;
          loadScenarioById(selectedId).catch((error) => {
            console.error('Scenario wisselen mislukt', error);
            statusEl.textContent = `Fout bij laden van scenario: ${error?.message ?? 'onbekende fout'}`;
          });
        });
      }


      const viewportSection = document.querySelector('.viewport');
      const loadingOverlay = document.createElement('div');
      loadingOverlay.className = 'loading-overlay loading-overlay--hidden';
      loadingOverlay.setAttribute('aria-hidden', 'true');

      const loadingSpinner = document.createElement('div');
      loadingSpinner.className = 'loading-overlay__spinner';
      loadingSpinner.setAttribute('role', 'status');
      loadingSpinner.setAttribute('aria-live', 'polite');
      loadingSpinner.setAttribute('aria-label', 'Bezig met laden');
      loadingOverlay.appendChild(loadingSpinner);

      viewportSection.appendChild(loadingOverlay);

      const activeLoadingTokens = new Set();
      let overlayHideTimeout = null;

      const showLoadingOverlay = (token = Symbol('loading')) => {
        if (activeLoadingTokens.has(token)) {
          return token;
        }
        if (overlayHideTimeout) {
          clearTimeout(overlayHideTimeout);
          overlayHideTimeout = null;
        }
        const wasEmpty = activeLoadingTokens.size === 0;
        activeLoadingTokens.add(token);
        if (wasEmpty) {
          loadingOverlay.classList.remove('loading-overlay--hidden');
          loadingOverlay.setAttribute('aria-hidden', 'false');
        }
        return token;
      };

      const hideLoadingOverlay = (token) => {
        if (token !== undefined) {
          activeLoadingTokens.delete(token);
        } else {
          activeLoadingTokens.clear();
        }
        if (activeLoadingTokens.size === 0) {
          overlayHideTimeout = window.setTimeout(() => {
            loadingOverlay.classList.add('loading-overlay--hidden');
            loadingOverlay.setAttribute('aria-hidden', 'true');
            overlayHideTimeout = null;
          }, 120);
        }
      };

      const evaluationOverlayToken = Symbol('evaluation');

      const sceneApi = initScene(canvas);
      const webgpuSupported = sceneApi.isWebGPUSupported();
      const graphRegistry = createGraphRegistry();

      graphRegistry.on('active-graph-changed', ({ id }) => {
        reflectActiveGraphInStatus(id);
      });

      graphRegistry.on('graph-removed', ({ id }) => {
        if (graphStatusRecords.delete(id)) {
          renderGraphStatusList();
        }
      });

      graphRegistry.on('graph-added', ({ id, metadata }) => {
        const updates = {};
        if (metadata) {
          if (metadata.label || metadata.name) {
            updates.label = metadata.label ?? metadata.name;
          }
          if (metadata.role) {
            updates.role = metadata.role;
          }
          if (metadata.variant) {
            updates.variant = metadata.variant;
          }
          if (metadata.source) {
            updates.source = metadata.source;
          }
          const scenarioLabel = metadata.scenarioLabel ?? metadata.scenario ?? metadata.scenarioId;
          if (scenarioLabel) {
            updates.scenarioLabel = scenarioLabel;
          }
        }
        updateGraphStatus(id, updates, { createIfMissing: true });
      });

      const workerManager = new GHXWorkerManager();
      await workerManager.ensureReady();

      const engine = createEngine({
        registry: defaultRegistry,
        graphRegistry,
        updateMesh: sceneApi.updateMesh,
        onLog: (message) => console.info('[engine]', message),
        onError: (message) => console.warn('[engine]', message)
      });

      const gatherSliderValuesForGraph = (graphId) => {
        const state = engine.graphStates.get(graphId);
        if (!state) {
          return [];
        }
        const values = [];
        for (const node of state.graph?.nodes ?? []) {
          if (!node) continue;
          const implementation = engine.componentRegistry.lookup(node);
          if (!implementation || implementation.type !== 'slider') continue;
          let nodeState = state.nodeStates.get(node.id);
          if (!nodeState && typeof implementation.createState === 'function') {
            nodeState = implementation.createState(node);
            if (nodeState) {
              state.nodeStates.set(node.id, nodeState);
            }
          }
          if (!nodeState) {
            continue;
          }
          const numericValue = Number(nodeState.value);
          if (!Number.isFinite(numericValue)) {
            continue;
          }
          values.push({ nodeId: node.id, value: numericValue, graphId });
        }
        return values;
      };

      let workerEvaluationInFlight = null;

      const evaluateWithWorker = async ({ emitStartEvent = true, reason = 'worker-evaluate' } = {}) => {
        const activeGraph = graphRegistry.getActiveGraph();
        if (!activeGraph) {
          if (emitStartEvent) {
            engine.emit('evaluation', { message: 'Geen actieve grafiek om te evalueren.' });
          }
          return;
        }

        if (emitStartEvent) {
          engine.emit('evaluation-start', { reason, graphId: activeGraph.id });
        }

        try {
          const sliderValues = gatherSliderValuesForGraph(activeGraph.id);
          const response = await workerManager.evaluateGraph({
            graphId: activeGraph.id,
            sliderValues,
            setActive: true,
          });

          if (Array.isArray(response?.sliders)) {
            let sliderChanged = false;
            for (const slider of response.sliders) {
              if (!slider) continue;
              const result = engine.setSliderValue(slider.id, slider.value, {
                graphId: slider.graphId ?? activeGraph.id,
                silent: true,
              });
              if (result) {
                sliderChanged = true;
              }
            }
            engine.refreshSliderLinks({ emit: sliderChanged });
          } else {
            engine.refreshSliderLinks({ emit: false });
          }

          if (response?.display) {
            const displayPayload = deserializeDisplayPayload(response.display);
            const graphMetadata = response?.metadata ?? displayPayload?.graphMetadata ?? null;
            sceneApi.updateMesh(displayPayload, {
              graphId: response.graphId,
              metadata: graphMetadata,
            });
          } else {
            sceneApi.updateMesh(null, { graphId: response.graphId });
          }

          const timestamp = new Date().toLocaleTimeString();
          const message = response?.summary
            ? `${response.summary} â€” ${timestamp}`
            : `Laatste evaluatie: ${timestamp}`;
          engine.emit('evaluation', { message });
        } catch (error) {
          console.error('Worker evaluation error', error);
          sceneApi.updateMesh(null, { graphId: activeGraph.id });
          engine.emit('evaluation', {
            message: `Worker evaluatie fout: ${error?.message ?? 'onbekende fout'}`,
          });
        } finally {
          engine.emit('evaluation-complete', { reason, graphId: activeGraph.id });
        }
      };

      engine.evaluate = function evaluateProxy(options = {}) {
        if (workerEvaluationInFlight) {
          return workerEvaluationInFlight;
        }
        const mergedOptions = { emitStartEvent: true, reason: 'worker-evaluate', ...options };
        const execution = evaluateWithWorker(mergedOptions);
        workerEvaluationInFlight = execution.finally(() => {
          workerEvaluationInFlight = null;
        });
        return workerEvaluationInFlight;
      };

      engine.scheduleEvaluation = function scheduleWorkerEvaluation() {
        if (!engine.activeGraphId) {
          return;
        }
        if (engine.pendingEvaluation || workerEvaluationInFlight) {
          return;
        }
        engine.pendingEvaluation = true;
        const trigger = () => {
          engine.pendingEvaluation = false;
          engine.evaluate({ emitStartEvent: false, reason: 'worker-schedule' });
        };
        const raf = typeof globalThis !== 'undefined' ? globalThis.requestAnimationFrame : undefined;
        if (typeof raf === 'function') {
          raf(trigger);
          return;
        }
        Promise.resolve().then(trigger);
      };

      const ui = createSliderUI({
        container: sliderContainer,
        engine,
      });

      engine.on('sliders-changed', ui.render);
      engine.on('evaluation', (payload) => {
        if (payload?.message) {
          statusEl.textContent = payload.message;
        }
      });
      engine.on('evaluation-start', (payload = {}) => {
        if (payload?.graphId) {
          updateGraphStatus(payload.graphId, {
            state: 'evaluating',
            message: 'Evaluatie bezigâ€¦',
          });
        }
        showLoadingOverlay(evaluationOverlayToken);
      });
      engine.on('evaluation-complete', (payload = {}) => {
        if (payload?.graphId) {
          const timestamp = new Date();
          const record = graphStatusRecords.get(payload.graphId);
          const summaryText = record?.summary;
          const evaluationMessage = summaryText
            ? `${summaryText} â€” Laatste evaluatie: ${timestamp.toLocaleTimeString()}`
            : `Laatste evaluatie: ${timestamp.toLocaleTimeString()}`;
          updateGraphStatus(payload.graphId, {
            state: 'ready',
            message: evaluationMessage,
            lastEvaluatedAt: timestamp,
          });
        }
        hideLoadingOverlay(evaluationOverlayToken);
      });

      const syncOverlay = (checked) => {
        overlayState.textContent = checked ? 'true' : 'false';
        overlayToggle.setAttribute('aria-checked', checked ? 'true' : 'false');
        sceneApi.setOverlayEnabled(checked);
      };

      overlayToggle.addEventListener('change', () => {
        syncOverlay(overlayToggle.checked);
      });

      syncOverlay(Boolean(overlayToggle.checked));

      if (!webgpuSupported) {
        statusEl.textContent = 'WebGPU wordt niet ondersteund in deze browser of op dit apparaat.';
      } else {
        sceneApi.whenRendererReady().catch((error) => {
          const reason = error?.message ? `WebGPU-fout: ${error.message}` : 'WebGPU kon niet worden geÃ¯nitialiseerd.';
          statusEl.textContent = reason;
        });
      }

      const summarizeGraph = (graph, metadata = {}) => {
        const nodeCount = metadata.nodeCount ?? graph?.nodes?.length ?? 0;
        const sliderCount = metadata.sliderCount ?? graph?.metadata?.sliderCount ?? 0;
        const wireCount = metadata.wireCount ?? graph?.wires?.length ?? 0;
        const summaryParts = [`${nodeCount} nodes`];
        summaryParts.push(sliderCount === 1 ? '1 slider' : `${sliderCount} sliders`);
        if (wireCount) {
          summaryParts.push(`${wireCount} wires`);
        }
        return summaryParts.join(', ');
      };

      if (SCENARIOS.length) {
        const defaultScenario = SCENARIOS[0];
        if (scenarioSelect) {
          scenarioSelect.value = defaultScenario.id;
        }
        await loadScenarioById(defaultScenario.id);
      } else {
        statusEl.textContent = 'Upload een GHX-bestand om te starten.';
      }

      fileInput.addEventListener('change', async () => {
        const file = fileInput.files?.[0];
        if (!file) {
          statusEl.textContent = 'Geen bestand geselecteerd.';
          return;
        }

        currentScenarioToken = null;
        activeScenarioId = null;
        setScenarioDescription(null);
        if (scenarioSelect) {
          scenarioSelect.value = '';
        }

        statusEl.textContent = `Bezig met inlezen van ${file.name}...`;
        const fileLoadToken = showLoadingOverlay();

        try {
          const contents = await file.text();
          const parseResult = await workerManager.parseText(contents, {
            name: file.name,
            setActive: true,
            metadata: {
              scenarioLabel: 'Upload',
              scenarioId: 'upload',
              source: file.name,
            },
          });

          engine.loadGraph(parseResult.graph, {
            id: parseResult.graphId,
            metadata: parseResult.metadata,
          });

          const summaryText = parseResult.summary ?? summarizeGraph(parseResult.graph, parseResult.metadata);
          const metadata = parseResult.metadata ?? {};
          updateGraphStatus(
            parseResult.graphId,
            {
              label: metadata.label ?? metadata.name ?? file.name,
              state: 'ready',
              message: summaryText ?? 'Grafiek geladen.',
              summary: summaryText,
              sliderCount: metadata.sliderCount ?? parseResult.sliders?.length,
              role: metadata.role ?? null,
              variant: metadata.variant ?? null,
              scenarioId: 'upload',
              scenarioLabel: 'Upload',
              source: file.name,
            },
            { createIfMissing: true },
          );

          await engine.evaluate({ reason: 'file-load' });

          statusEl.textContent = `GHX geladen: ${summaryText}.`;
        } catch (error) {
          console.error('GHX parse error', error);
          statusEl.textContent = `Fout bij inlezen: ${error?.message ?? 'onbekende fout'}`;
        } finally {
          hideLoadingOverlay(fileLoadToken);
        }
      });
    </script>
  </body>
</html>
