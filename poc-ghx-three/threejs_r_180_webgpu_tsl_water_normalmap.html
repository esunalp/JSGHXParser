<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Three.js r180 • WebGPU • TSL Water (procedurale normalflow)</title>
  <style>
    html, body { margin: 0; height: 100%; background: #12161b; color: #dfe7ef; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; left: 10px; top: 10px; padding: 8px 10px; background: rgba(0,0,0,.4); border-radius: 8px; backdrop-filter: blur(4px); }
    .hud label { display:block; opacity:.85 }
    a { color:#8ad; text-decoration: none; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div><strong>TSL Water • WebGPU</strong></div>
    <label>Roteer/zoom met de muis.</label>
    <label>Normal perturbatie: fBm noise • scroll & flow</label>
  </div>
    <script type="importmap">
      {
        "imports": {
        	"three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.webgpu.js",
		    "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.webgpu.js",
        	"three/tsl": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.tsl.js",
        	"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
    	}
      }
    </script>
  <script type="module">
    // Three.js r180 (ESM) + WebGPU + TSL (Nodes.js)
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

	// TSL / Node helpers (r180):
	// Haal alle TSL-functies uit het 'THREE' object
	import {
        // core varying/uniform helpers
        nodeObject, uv, time, uniform, cameraPosition, positionWorld, normalWorld,
        // math primitives
        vec2, vec3, float, add, sub, mul, div, fract, sin, clamp,
        dot, normalize, floor, mix, pow,
        // function builder
        Fn
    } from 'three/tsl';

	  class InstanceUniformNode extends THREE.Node {

				constructor() {
					super( 'vec3' );
					this.updateType = THREE.NodeUpdateType.OBJECT;
					this.uniformNode = uniform( new THREE.Color() );
				}
				update( frame ) {
					const mesh = frame.object;
					const meshColor = mesh.color;
					this.uniformNode.value.copy( meshColor );
				}
				setup( /*builder*/ ) {
					return this.uniformNode;
				}
	  }

    const app = document.getElementById('app');

    // --- Renderer (WebGPU) ---
    let renderer;
    try {
      renderer = new THREE.WebGPURenderer({ antialias: true, alpha: false });
    } catch (e) {
      const msg = document.createElement('div');
      msg.style.cssText = 'position:fixed;inset:0;display:grid;place-items:center;padding:24px;text-align:center;';
      msg.innerHTML = '<b>WebGPU niet beschikbaar</b><br>Gebruik een recente Chrome/Edge/Firefox Nightly en zet WebGPU aan.';
      document.body.appendChild(msg);
      throw e;
    }
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    app.appendChild(renderer.domElement);

    // --- Scene & Camera ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a2026);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 3.2, 7);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0.2, -2);

    // --- Lights ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(3, 6, 2);
    scene.add(dir);

    // Optional: simpele LDR-omgeving voor highlights (PMREM)
    const pmrem = new THREE.PMREMGenerator(renderer);
    const texLoader = new THREE.TextureLoader();
    texLoader.setCrossOrigin('anonymous');
    texLoader.load(
		'https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg',
  		async (tex) => { // <-- Maak de functie async
    	const envTarget = await pmrem.fromEquirectangularAsync(tex); // <-- Gebruik Async en await
    	scene.environment = envTarget.texture; // <-- De textuur zit op het resultaat
    	tex.dispose();
    	envTarget.dispose(); // <-- Ruim ook de render target op
      }
    );

    // ===============================
    //  Procedurale normalberekening
    // ===============================

    // Uniforms voor random/flow/scale
    const uSeed       = InstanceUniformNode( new THREE.Vector2(Math.random()*1000, Math.random()*1000) );
    const uScale      = InstanceUniformNode( 8.0 );           // detail schaal
    const uOctaves    = InstanceUniformNode( 4.0 );
    const uLacunarity = InstanceUniformNode( 2.0 );
    const uGain       = InstanceUniformNode( 0.5 );

    const uFlowDirA   = InstanceUniformNode( new THREE.Vector2(0.11, 0.07) );
    const uFlowDirB   = InstanceUniformNode( new THREE.Vector2(-0.08, 0.13) );
    const uSpeed      = InstanceUniformNode( 0.05 );
    const uStrength   = InstanceUniformNode( 1.2 );

    // 2D hash/noise helpers in TSL
    const hash2 = Fn( (p) => {
      const dotp = dot(p, vec2(float(127.1), float(311.7)));
      const s = sin(dotp).mul(float(43758.5453123));
      return fract(vec2(s, s.mul(float(1.2154))));
    }, ['vec2']);

    const noise2 = Fn( (p) => {
      const i = floor(p);
      const f = fract(p);

      const a = dot( hash2( i ), f );
      const b = dot( hash2( add(i, vec2(float(1.0), float(0.0))) ), sub(f, vec2(float(1.0), float(0.0))) );
      const c = dot( hash2( add(i, vec2(float(0.0), float(1.0))) ), sub(f, vec2(float(0.0), float(1.0))) );
      const d = dot( hash2( add(i, vec2(float(1.0), float(1.0))) ), sub(f, vec2(float(1.0), float(1.0))) );

      const u = mul(f,f).mul( sub(float(3.0), mul(float(2.0), f)) ); // smoothstep(f)
      const lerpX1 = mix(a,b,u.x);
      const lerpX2 = mix(c,d,u.x);
      return mix(lerpX1, lerpX2, u.y);
    }, ['vec2']);

    const fbm = Fn( (p, octaves, lacunarity, gain) => {
      let amp = float(0.5);
      let freq = float(1.0);
      let sum = float(0.0);
      for (let i=0;i<5;i++) {
        const contrib = noise2( mul(p, freq) ).mul(amp);
        sum = add(sum, contrib);
        freq = mul(freq, lacunarity);
        amp  = mul(amp,  gain);
      }
      const o = clamp(octaves, float(1.0), float(5.0));
      return sum.mul( div(o, float(5.0)) );
    }, ['vec2','float','float','float']);

    // ===============================
    //  Watermateriaal: procedural normal
    // ===============================

    const uNormalScale = uniform( 1.0 );
    const uScroll      = uniform( new THREE.Vector2(0.03, 0.02) );

    const fresnelSchlick = Fn( (cosTheta, F0) => {
      const one = float(1.0);
      return add(F0, mul( sub(one, F0), pow( sub(one, cosTheta), float(5.0) )));
    }, ['float','vec3']);

    const makeWaterMaterial = () => {
      const st = uv();
      const stFlow = add(st, mul(time, uScroll));
      const tFlow = time.mul(uSpeed);

      const pA = add( mul(stFlow, uScale), add( uSeed, mul(uFlowDirA, tFlow) ) );
      const pB = add(
        mul( stFlow, uScale.mul(float(1.73)) ),
        add( add( uSeed, vec2(float(10.0), float(10.0)) ), mul( uFlowDirB, tFlow.mul(float(1.3)) ) )
      );

      const eps = float(0.002);
      const epsX = vec2(eps, float(0.0));
      const epsY = vec2(float(0.0), eps);

      const hXPos = add(
        fbm(add(pA, epsX), uOctaves, uLacunarity, uGain),
        fbm(add(pB, epsX), uOctaves, uLacunarity, uGain).mul(float(0.7))
      );
      const hXNeg = add(
        fbm(sub(pA, epsX), uOctaves, uLacunarity, uGain),
        fbm(sub(pB, epsX), uOctaves, uLacunarity, uGain).mul(float(0.7))
      );
      const hYPos = add(
        fbm(add(pA, epsY), uOctaves, uLacunarity, uGain),
        fbm(add(pB, epsY), uOctaves, uLacunarity, uGain).mul(float(0.7))
      );
      const hYNeg = add(
        fbm(sub(pA, epsY), uOctaves, uLacunarity, uGain),
        fbm(sub(pB, epsY), uOctaves, uLacunarity, uGain).mul(float(0.7))
      );

      const invStep = div(float(0.5), eps);
      const scaledStrength = mul(uStrength, invStep);
      const slopeX = mul( sub(hXPos, hXNeg), mul(scaledStrength, float(-1.0)) );
      const slopeY = mul( sub(hYPos, hYNeg), mul(scaledStrength, float(-1.0)) );

      const nTex = normalize( vec3( slopeX, slopeY, float(1.0) ) );

      const baseN = normalize( normalWorld );
      const pertN = normalize( add( baseN, mul(nTex, uNormalScale) ) );

      const V = normalize( sub(cameraPosition, positionWorld) );
      const cosTheta = clamp( dot( pertN, normalize(V) ), float(0.0), float(1.0) );
      const F0 = vec3(float(0.02), float(0.02), float(0.02)); // water base reflectie
      const F = fresnelSchlick( cosTheta, F0 );

      const mat = new THREE.MeshStandardNodeMaterial({ metalness: 0.0, roughness: 0.05 });
      mat.normalNode    = pertN;
      mat.colorNode     = vec3(float(0.02), float(0.07), float(0.09));
      mat.metalnessNode = float(0.0);
      mat.roughnessNode = float(0.05);
      mat.emissiveNode  = F.mul(float(0.35)); // simpele highlight
      return mat;
    };

    // --- Water mesh ---
    const waterGeo = new THREE.PlaneGeometry(24, 24, 1, 1);
    waterGeo.rotateX(-Math.PI / 2);
    const waterMat = makeWaterMaterial();
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.position.y = 0.0;
    scene.add(water);

    // --- Referentie objecten ---
  	// Gebruik ook hier MeshStandardNodeMaterial (geïmporteerd uit 'tsl')
  	const boxMat = new THREE.MeshStandardNodeMaterial({ metalness: 0.2, roughness: 0.4 });
  	boxMat.colorNode = vec3(float(0x5599ff) / 255); // Converteer kleur naar TSL-node

  	const box = new THREE.Mesh(
    	new THREE.BoxGeometry(1, 1, 1),
    	boxMat
  	);
  	box.position.set(-1.2, 0.5, -2.0);
  	scene.add(box);

  	const torusMat = new THREE.MeshStandardNodeMaterial({ metalness: 0.0, roughness: 0.25 });
  	torusMat.colorNode = vec3(float(0xffaa33) / 255); // Converteer kleur naar TSL-node

  	const torus = new THREE.Mesh(
    	new THREE.TorusKnotGeometry(0.6, 0.2, 120, 32),
    	torusMat
  	);
  	torus.position.set(1.6, 1.1, -3);
  	scene.add(torus);

    // --- Animatie lus ---
    function onResize() {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    renderer.setAnimationLoop(() => {
      torus.rotation.y += 0.01;
      renderer.render(scene, camera);
    });

    // --- Eenvoudige hotkeys ---
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') {
        uSeed.value.set(Math.random()*1000, Math.random()*1000);
      }
    });

  </script>
</body>
</html>
