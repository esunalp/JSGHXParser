<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Three.js r180 • WebGPU • TSL Water (procedurale normalmap 1024²)</title>
  <style>
    html, body { margin: 0; height: 100%; background: #12161b; color: #dfe7ef; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; left: 10px; top: 10px; padding: 8px 10px; background: rgba(0,0,0,.4); border-radius: 8px; backdrop-filter: blur(4px); }
    .hud label { display:block; opacity:.85 }
    a { color:#8ad; text-decoration: none; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div><strong>TSL Water • WebGPU</strong></div>
    <label>Roteer/zoom met de muis.</label>
    <label>Normalmap: 1024×1024 • fBm noise • scroll & flow</label>
  </div>
    <script type="importmap">
      {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.webgpu.js",
            "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.webgpu.js",
            "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.tsl.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
        }
      }
    </script>
  <script type="module">
    // Three.js r180 (ESM) + WebGPU + TSL (Nodes.js)
    import * as THREE from 'three/webgpu';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // TSL / Node helpers (r180):
    import {
      // core varying/uniform helpers
      uv, time, uniform, cameraViewPosition, positionLocal, normalWorld,
      // math primitives
      vec2, vec3, vec4, float, add, sub, mul, div, fract, sin, cos, abs, max, min, clamp,
      dot, normalize, length, floor, step, mix, pow,
      // texture helpers
      texture,
      // function builder
      Fn as tslFn
    } from 'three/tsl';
	

    const app = document.getElementById('app');

    // --- Renderer (WebGPU) ---
    let renderer;
    try {
      renderer = new THREE.WebGPURenderer({ antialias: true, alpha: false });
    } catch (e) {
      const msg = document.createElement('div');
      msg.style.cssText = 'position:fixed;inset:0;display:grid;place-items:center;padding:24px;text-align:center;';
      msg.innerHTML = '<b>WebGPU niet beschikbaar</b><br>Gebruik een recente Chrome/Edge/Firefox Nightly en zet WebGPU aan.';
      document.body.appendChild(msg);
      throw e;
    }
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    app.appendChild(renderer.domElement);

    // --- Scene & Camera ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a2026);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 3.2, 7);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0.2, -2);

    // --- Lights ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(3, 6, 2);
    scene.add(dir);

    // Optional: simpele LDR-omgeving voor highlights (PMREM)
    const pmrem = new THREE.PMREMGenerator(renderer);
    const texLoader = new THREE.TextureLoader();
    texLoader.setCrossOrigin('anonymous');
    texLoader.load(
      'https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg',
      (tex) => {
        const env = pmrem.fromEquirectangular(tex).texture;
        scene.environment = env;
        tex.dispose();
      }
    );

    // ===============================
    //  Procedurale NORMALMAP (1024²)
    // ===============================

    // Uniforms voor random/flow/scale
    const uSeed       = uniform( vec2(Math.random()*1000, Math.random()*1000) );
    const uScale      = uniform( float(8.0) );           // detail schaal
    const uOctaves    = uniform( float(4.0) );
    const uLacunarity = uniform( float(2.0) );
    const uGain       = uniform( float(0.5) );

    const uFlowDirA   = uniform( vec2( 0.11,  0.07) );
    const uFlowDirB   = uniform( vec2(-0.08,  0.13) );
    const uSpeed      = uniform( float(0.05) );
    const uStrength   = uniform( float(1.2) );

    // 2D hash/noise helpers in TSL
    const hash2 = tslFn( (p) => {
      const dotp = dot(p, vec2(127.1, 311.7));
      const s = sin(dotp).mul(43758.5453123);
      return fract(vec2(s, s.mul(1.2154)));
    }, ['vec2']);

    const noise2 = tslFn( (p) => {
      const i = floor(p);
      const f = fract(p);

      const a = dot( hash2( i ), f );
      const b = dot( hash2( add(i, vec2(1,0)) ), sub(f, vec2(1,0)) );
      const c = dot( hash2( add(i, vec2(0,1)) ), sub(f, vec2(0,1)) );
      const d = dot( hash2( add(i, vec2(1,1)) ), sub(f, vec2(1,1)) );

      const u = mul(f,f).mul( sub(float(3), mul(float(2), f)) ); // smoothstep(f)
      const lerpX1 = mix(a,b,u.x);
      const lerpX2 = mix(c,d,u.x);
      return mix(lerpX1, lerpX2, u.y);
    }, ['vec2']);

    const fbm = tslFn( (p, octaves, lacunarity, gain) => {
      let amp = float(0.5);
      let freq = float(1.0);
      let sum = float(0.0);
      for (let i=0;i<5;i++) {
        const contrib = noise2( mul(p, freq) ).mul(amp);
        sum = add(sum, contrib);
        freq = mul(freq, lacunarity);
        amp  = mul(amp,  gain);
      }
      const o = clamp(octaves, 1.0, 5.0);
      return sum.mul( div(o, 5.0) );
    }, ['vec2','float','float','float']);

    const encodeNormal = tslFn( (n) => {
      return vec4( mul(add(n, 1.0), 0.5), 1.0 );
    }, ['vec3']);

    const makeNormalGenMaterial = () => {
      const st = uv();
      const t = time.mul(uSpeed);

      const pA = add( st.mul(uScale), add( uSeed, uFlowDirA.mul(t) ) );
      const pB = add( st.mul(uScale*1.73), add( uSeed.add(10.0), uFlowDirB.mul(t*1.3) ) );

      const hA = fbm(pA, uOctaves, uLacunarity, uGain);
      const hB = fbm(pB, uOctaves, uLacunarity, uGain);
      const h  = add( hA, hB.mul(0.7) );

      const eps = float(0.002);
      const dHx = sub(
        add( fbm(add(pA, vec2(eps,0)), uOctaves, uLacunarity, uGain), fbm(add(pB, vec2(eps,0)), uOctaves, uLacunarity, uGain).mul(0.7) ),
        add( fbm(add(pA, vec2(-eps,0)), uOctaves, uLacunarity, uGain), fbm(add(pB, vec2(-eps,0)), uOctaves, uLacunarity, uGain).mul(0.7) )
      ).mul( 0.5/eps );

      const dHy = sub(
        add( fbm(add(pA, vec2(0,eps)), uOctaves, uLacunarity, uGain), fbm(add(pB, vec2(0,eps)), uOctaves, uLacunarity, uGain).mul(0.7) ),
        add( fbm(add(pA, vec2(0,-eps)), uOctaves, uLacunarity, uGain), fbm(add(pB, vec2(0,-eps)), uOctaves, uLacunarity, uGain).mul(0.7) )
      ).mul( 0.5/eps );

      const n = normalize( vec3( mul(-dHx, uStrength), mul(-dHy, uStrength), 1.0 ) );
      const color = encodeNormal(n);

      const mat = new THREE.MeshBasicNodeMaterial();
      mat.colorNode = color; // schrijf RGBA normal
      return mat;
    };

    // Render target 1024×1024 voor normalmap
    const normalSize = 1024;
    const normalTarget = new THREE.RenderTarget(normalSize, normalSize, {
      type: THREE.FloatType,
      depthBuffer: false,
      stencilBuffer: false,
      generateMipmaps: true
    });
    normalTarget.texture.magFilter = THREE.LinearFilter;
    normalTarget.texture.minFilter = THREE.LinearMipmapLinearFilter;
    normalTarget.texture.wrapS = THREE.RepeatWrapping;
    normalTarget.texture.wrapT = THREE.RepeatWrapping;

    const orthoScene = new THREE.Scene();
    const orthoCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), makeNormalGenMaterial());
    orthoScene.add(quad);

    // ===============================
    //  Watermateriaal: normal perturb
    // ===============================

    const uNormalScale = uniform( float(1.0) );
    const uScroll      = uniform( vec2(0.03, 0.02) );

    const decodeNormal = tslFn( (rgba) => {
      const n = mul( sub(rgba.xyz, 0.5), 2.0 );
      return normalize(n);
    }, ['vec4']);

    const fresnelSchlick = tslFn( (cosTheta, F0) => {
      return add(F0, mul( sub(1.0, F0), pow( sub(1.0, cosTheta), 5.0 )));
    }, ['float','vec3']);

    const makeWaterMaterial = () => {
      const st = uv();
      const stFlow = add(st, mul(time, uScroll));
      const nTex = decodeNormal( texture( normalTarget.texture, stFlow ) );

      const baseN = normalize( normalWorld );
      const pertN = normalize( add( baseN, mul(nTex, uNormalScale) ) );

      const V = normalize( sub(cameraViewPosition, positionLocal) );
      const cosTheta = clamp( dot( pertN, normalize(V) ), 0.0, 1.0 );
      const F0 = vec3(0.02); // water base reflectie
      const F = fresnelSchlick( cosTheta, F0 );

      const mat = new THREE.MeshStandardNodeMaterial({ metalness: 0.0, roughness: 0.05 });
      mat.normalNode    = pertN;
      mat.colorNode     = vec3(0.02, 0.07, 0.09);
      mat.metalnessNode = float(0.0);
      mat.roughnessNode = float(0.05);
      mat.emissiveNode  = F.mul(0.35); // simpele highlight
      return mat;
    };

    // --- Water mesh ---
    const waterGeo = new THREE.PlaneGeometry(24, 24, 1, 1);
    waterGeo.rotateX(-Math.PI / 2);
    const waterMat = makeWaterMaterial();
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.position.y = 0.0;
    scene.add(water);

    // --- Referentie objecten ---
    const box = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({ color: 0x5599ff, metalness: 0.2, roughness: 0.4 })
    );
    box.position.set(-1.2, 0.5, -2.0);
    scene.add(box);

    const torus = new THREE.Mesh(
      new THREE.TorusKnotGeometry(0.6, 0.2, 120, 32),
      new THREE.MeshStandardMaterial({ color: 0xffaa33, metalness: 0.0, roughness: 0.25 })
    );
    torus.position.set(1.6, 1.1, -3);
    scene.add(torus);

    // --- Animatie lus ---
    function renderNormalMap() {
      renderer.setRenderTarget(normalTarget);
      renderer.render(orthoScene, orthoCam);
      renderer.setRenderTarget(null);
    }

    function onResize() {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    renderer.setAnimationLoop(() => {
      renderNormalMap();
      torus.rotation.y += 0.01;
      renderer.render(scene, camera);
    });

    // --- Eenvoudige hotkeys ---
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') {
        uSeed.value.set(Math.random()*1000, Math.random()*1000);
      }
    });

  </script>
</body>
</html>
