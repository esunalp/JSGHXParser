{
  "version": 3,
  "file": "three_integration.js",
  "sources": [
    "three_integration.js"
  ],
  "sourcesContent": [
    "import * as THREE from 'three/webgpu';\nimport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\nTHREE.Object3D.DEFAULT_UP.set(0, 0, 1);\n\nconst DEFAULT_CAMERA_POSITION = new THREE.Vector3(600, -600, 400);\nconst DEFAULT_CAMERA_TARGET = new THREE.Vector3(0, 0, 0);\nconst TEMP_BOX = new THREE.Box3();\nconst TEMP_SPHERE = new THREE.Sphere();\n\nfunction isWebGPUAvailable() {\n  if (typeof navigator === 'undefined') {\n    return false;\n  }\n  return Boolean(navigator.gpu) && typeof THREE.WebGPURenderer === 'function';\n}\n\nfunction getViewportSize(canvas) {\n  const width = canvas?.clientWidth ?? canvas?.parentElement?.clientWidth ?? window.innerWidth ?? 1;\n  const height = canvas?.clientHeight ?? canvas?.parentElement?.clientHeight ?? window.innerHeight ?? 1;\n  return {\n    width: Math.max(1, Math.floor(width)),\n    height: Math.max(1, Math.floor(height)),\n    pixelRatio: Math.min(window.devicePixelRatio ?? 1, 2),\n  };\n}\n\nfunction applyRendererDefaults(renderer) {\n  if (!renderer) {\n    return;\n  }\n  if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) {\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n  }\n  if ('physicallyCorrectLights' in renderer) {\n    renderer.physicallyCorrectLights = true;\n  }\n  if ('toneMapping' in renderer && THREE.ACESFilmicToneMapping) {\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n  }\n  if ('shadowMap' in renderer && renderer.shadowMap) {\n    renderer.shadowMap.enabled = true;\n  }\n  if (typeof renderer.setClearColor === 'function') {\n    renderer.setClearColor(0x11161f, 1);\n  }\n}\n\nfunction disposeMaterial(material) {\n  if (!material) {\n    return;\n  }\n  if (Array.isArray(material)) {\n    material.forEach(disposeMaterial);\n    return;\n  }\n  if (typeof material.dispose === 'function') {\n    material.dispose();\n  }\n}\n\nfunction disposeObject(object) {\n  if (!object) {\n    return;\n  }\n  if (object.children?.length) {\n    [...object.children].forEach((child) => {\n      disposeObject(child);\n    });\n  }\n  if (object.geometry && typeof object.geometry.dispose === 'function') {\n    object.geometry.dispose();\n  }\n  disposeMaterial(object.material);\n}\n\nfunction createSurfaceMesh(item) {\n  if (!Array.isArray(item.vertices) || item.vertices.length === 0) {\n    return null;\n  }\n\n  const positions = new Float32Array(item.vertices.flat());\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n  if (Array.isArray(item.faces) && item.faces.length) {\n    const indices = item.faces.flat();\n    let maxIndex = 0;\n    for (const value of indices) {\n      if (typeof value === 'number' && value > maxIndex) {\n        maxIndex = value;\n      }\n    }\n    const typedArray =\n      maxIndex > 65535 ? new Uint32Array(indices) : new Uint16Array(indices);\n    geometry.setIndex(new THREE.BufferAttribute(typedArray, 1));\n  }\n\n  geometry.computeVertexNormals();\n  geometry.computeBoundingSphere();\n\n  const material = new THREE.MeshStandardMaterial({\n    color: 0x3c82ff,\n    metalness: 0.1,\n    roughness: 0.65,\n    side: THREE.DoubleSide,\n  });\n\n  const mesh = new THREE.Mesh(geometry, material);\n  mesh.castShadow = true;\n  mesh.receiveShadow = true;\n  mesh.userData.generatedByGHX = true;\n  return mesh;\n}\n\nfunction createLineObject(item) {\n  if (!Array.isArray(item.points) || item.points.length < 2) {\n    return null;\n  }\n  const points = item.points\n    .map((point) => (Array.isArray(point) && point.length >= 3 ? new THREE.Vector3(point[0], point[1], point[2]) : null))\n    .filter(Boolean);\n  if (points.length < 2) {\n    return null;\n  }\n  const geometry = new THREE.BufferGeometry().setFromPoints(points);\n  const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });\n  const line = new THREE.Line(geometry, material);\n  line.userData.generatedByGHX = true;\n  line.userData.overlay = true;\n  return line;\n}\n\nfunction createPointObject(item) {\n  if (!Array.isArray(item.coordinates) || item.coordinates.length < 3) {\n    return null;\n  }\n  const geometry = new THREE.SphereGeometry(12, 18, 14);\n  const material = new THREE.MeshStandardMaterial({ color: 0xffaa33, emissive: 0x111111 });\n  const point = new THREE.Mesh(geometry, material);\n  point.position.set(item.coordinates[0], item.coordinates[1], item.coordinates[2]);\n  point.castShadow = true;\n  point.userData.generatedByGHX = true;\n  point.userData.overlay = true;\n  return point;\n}\n\nfunction focusCamera(camera, controls, groups) {\n  TEMP_BOX.makeEmpty();\n  for (const group of groups) {\n    if (group) {\n      TEMP_BOX.expandByObject(group);\n    }\n  }\n\n  if (TEMP_BOX.isEmpty()) {\n    camera.position.copy(DEFAULT_CAMERA_POSITION);\n    controls.target.copy(DEFAULT_CAMERA_TARGET);\n    controls.update();\n    return;\n  }\n\n  TEMP_BOX.getBoundingSphere(TEMP_SPHERE);\n  const center = TEMP_SPHERE.center;\n  const radius = Math.max(TEMP_SPHERE.radius, 1);\n  const offset = new THREE.Vector3(1.2, -1.0, 0.75).normalize().multiplyScalar(radius * 3.2);\n\n  camera.position.copy(center.clone().add(offset));\n  controls.target.copy(center);\n  controls.update();\n}\n\nexport function createThreeApp(canvas) {\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x11161f);\n\n  const ambient = new THREE.AmbientLight(0xffffff, 0.55);\n  const directional = new THREE.DirectionalLight(0xffffff, 0.9);\n  directional.position.set(450, -320, 520);\n  directional.castShadow = true;\n  directional.shadow.mapSize.set(1024, 1024);\n  directional.shadow.camera.near = 0.1;\n  directional.shadow.camera.far = 5000;\n\n  scene.add(ambient);\n  scene.add(directional);\n\n  const grid = new THREE.GridHelper(2000, 40, 0x2c3646, 0x1a2130);\n  if (Array.isArray(grid.material)) {\n    for (const material of grid.material) {\n      material.transparent = true;\n      material.opacity = 0.35;\n    }\n  } else if (grid.material) {\n    grid.material.transparent = true;\n    grid.material.opacity = 0.35;\n  }\n  grid.rotation.x = Math.PI / 2;\n  scene.add(grid);\n\n  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100000);\n  camera.position.copy(DEFAULT_CAMERA_POSITION);\n  camera.up.set(0, 0, 1);\n\n  const controls = new OrbitControls(camera, canvas);\n  controls.enableDamping = true;\n  controls.dampingFactor = 0.08;\n  controls.target.copy(DEFAULT_CAMERA_TARGET);\n  controls.update();\n\n  const geometryGroup = new THREE.Group();\n  geometryGroup.name = 'ghx-geometry';\n  const overlayGroup = new THREE.Group();\n  overlayGroup.name = 'ghx-overlay';\n  overlayGroup.visible = true;\n\n  scene.add(geometryGroup);\n  scene.add(overlayGroup);\n\n  const overlayObjects = new Set();\n  const state = {\n    renderer: null,\n    overlayEnabled: true,\n  };\n\n  const handleResize = () => {\n    if (!state.renderer) {\n      return;\n    }\n    const viewport = getViewportSize(canvas);\n    camera.aspect = viewport.width / viewport.height;\n    camera.updateProjectionMatrix();\n    state.renderer.setPixelRatio(viewport.pixelRatio);\n    state.renderer.setSize(viewport.width, viewport.height, false);\n  };\n\n  const ready = (async () => {\n    if (!isWebGPUAvailable()) {\n      throw new Error('WebGPU wordt niet ondersteund in deze omgeving.');\n    }\n    const renderer = new THREE.WebGPURenderer({ canvas, antialias: true });\n    await renderer.init();\n    applyRendererDefaults(renderer);\n    state.renderer = renderer;\n    handleResize();\n    renderer.setAnimationLoop(() => {\n      controls.update();\n      renderer.render(scene, camera);\n    });\n  })();\n\n  ready.catch(() => {\n    // Laat de foutafhandeling over aan de aanroeper\n  });\n\n  if (typeof window !== 'undefined') {\n    window.addEventListener('resize', handleResize);\n  }\n\n  const clearGroup = (group) => {\n    if (!group) {\n      return;\n    }\n    const children = [...group.children];\n    for (const child of children) {\n      group.remove(child);\n      disposeObject(child);\n    }\n  };\n\n  const updateGeometry = (items) => {\n    clearGroup(geometryGroup);\n    clearGroup(overlayGroup);\n    overlayObjects.clear();\n\n    if (!Array.isArray(items) || !items.length) {\n      focusCamera(camera, controls, [geometryGroup, overlayGroup]);\n      return;\n    }\n\n    for (const item of items) {\n      if (!item || typeof item !== 'object') {\n        continue;\n      }\n      if (item.type === 'Surface') {\n        const mesh = createSurfaceMesh(item);\n        if (mesh) {\n          geometryGroup.add(mesh);\n        }\n      } else if (item.type === 'CurveLine') {\n        const line = createLineObject(item);\n        if (line) {\n          overlayGroup.add(line);\n          overlayObjects.add(line);\n        }\n      } else if (item.type === 'Point') {\n        const point = createPointObject(item);\n        if (point) {\n          overlayGroup.add(point);\n          overlayObjects.add(point);\n        }\n      }\n    }\n\n    overlayGroup.visible = state.overlayEnabled;\n    for (const object of overlayObjects) {\n      object.visible = state.overlayEnabled;\n    }\n\n    focusCamera(camera, controls, [geometryGroup, overlayGroup]);\n  };\n\n  const setOverlayEnabled = (enabled) => {\n    state.overlayEnabled = Boolean(enabled);\n    overlayGroup.visible = state.overlayEnabled;\n    for (const object of overlayObjects) {\n      object.visible = state.overlayEnabled;\n    }\n  };\n\n  const dispose = () => {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('resize', handleResize);\n    }\n    if (state.renderer) {\n      state.renderer.setAnimationLoop(null);\n      state.renderer.dispose();\n      state.renderer = null;\n    }\n    clearGroup(geometryGroup);\n    clearGroup(overlayGroup);\n    overlayObjects.clear();\n  };\n\n  // Standaard overlay state gelijk houden met UI\n  setOverlayEnabled(true);\n\n  return {\n    ready,\n    updateGeometry,\n    setOverlayEnabled,\n    isWebGPUSupported: () => Boolean(state.renderer),\n    dispose,\n  };\n}\n\n//# sourceMappingURL=three_integration.js.map\n"
  ],
  "names": [],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}